<!DOCTYPE html>
<html lang="en" data-theme="dark">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Existing CSS link for the reading list -->
    <link rel="stylesheet" href="./landing-style.css" />

    <title>bb.radz' library</title>

    <!-- Inlined styles -->
    <style>
      /**********************
       * Game of Life Canvas 
       **********************/
      .game-of-life {
        float: left;
        margin: 20px;
      }

      /**********************
       * Reading List Layout 
       **********************/
      /* 
         Moved the entire reading-list + graph down 
         from the header by adding margin-top 
       */
      .reading-list-layout {
        margin-top: 80px;
        margin-right: 10px;
        margin-left: 260px;
        display: flex;
        align-items: flex-start;
        gap: 20px;
      }

      .container {
        max-width: 600px;
        margin: 20px;
        padding: 20px;
        flex-shrink: 1;
      }

      body {
        font-family: Arial, sans-serif;
        line-height: 1.6;
      }

      h1 {
        text-align: center;
        color: var(--text-color);
        font-size: 2.5em;
        font-weight: bold;
      }

      ul {
        list-style: none;
        padding: 0;
      }

      li {
        margin-bottom: 10px;
        padding-bottom: 10px;
        border-bottom: 1px solid var(--border-color);
        position: relative;
        padding-left: 25px;
      }

      .read-indicator {
        position: absolute;
        left: 0;
        top: 50%;
        transform: translateY(-50%);
        color: #4caf50;
        font-size: 1.2em;
        font-weight: bold;
      }

      .item-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        flex-wrap: wrap;
      }

      .item-title {
        flex: 1;
      }

      .tags {
        display: flex;
        gap: 5px;
        margin-left: 10px;
      }

      .tags span {
        display: inline-block;
        padding: 3px 6px;
        border-radius: 4px;
        font-size: 0.9em;
        color: #fff;
      }

      .description {
        margin-top: 1px;
        font-size: 0.9em;
        color: var(--text-secondary);
      }

      .meta {
        font-size: 0.8em;
        color: var(--text-secondary);
      }

      .download-link {
        margin-top: 1px;
        text-decoration: none;
        color: #358297;
        font-size: 14px;
      }

      .search-bar {
        margin-bottom: 10px;
        text-align: center;
        display: flex;
        justify-content: space-between;
        gap: 10px;
      }

      .search-bar input {
        flex: 1;
        padding: 10px;
        font-size: 1em;
        border: 1px solid var(--border-color);
        border-radius: 5px;
        background: var(--background-color);
        color: var(--text-color);
      }

      .search-bar button,
      .sort-bar button {
        padding: 10px 20px;
        font-size: 1em;
        border: none;
        border-radius: 5px;
        background-color: var(--button-bg);
        color: var(--text-color);
        cursor: pointer;
      }

      .search-bar button:hover,
      .sort-bar button:hover {
        background-color: var(--button-hover-bg);
      }

      .sort-bar {
        margin-bottom: 30px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
      }

      .sort-bar button {
        margin: 5px;
        padding: 5px 10px;
        font-size: 0.9em;
      }

      .sort-bar button.active {
        background-color: var(--active-color, #2196f3);
        color: var(--active-text-color, #fff);
      }

      .active-tag {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }

      .active-tag span {
        display: inline-flex;
        justify-content: space-between;
        align-items: center;
        padding: 5px 10px;
        margin: 5px;
        border-radius: 5px;
        font-size: 0.9em;
        color: #fff;
        position: relative;
        gap: 10px;
      }

      .active-tag span::after {
        content: "\00d7";
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 16px;
        height: 16px;
        font-size: 0.8em;
        border-radius: 50%;
        background: rgba(0, 0, 0, 0.2);
        cursor: pointer;
        color: inherit;
      }

      /*************
       * THEME VARS
       *************/
      :root[data-theme="dark"] {
        --background-color: #1a1a1a;
        --text-color: #ffffff;
        --text-secondary: #999999;
        --border-color: #333333;
        --button-bg: #333333;
        --button-hover-bg: #444444;
        --graph-background: #121111;

        /* Graph colors for dark mode */
        --node-color: #e0e0e0;
        --node-stroke-color: #999999;
        --edge-color: #666666;
        --edge-opacity: 0.8;
      }

      :root[data-theme="light"] {
        --background-color: #ffffff;
        --text-color: #333333;
        --text-secondary: #666666;
        --border-color: #dddddd;
        --button-bg: #e0e0e0;
        --button-hover-bg: #bbbbbb;
        --graph-background: #ffffff;

        /* Graph colors for light mode */
        --node-color: #e0e0e0;
        --node-stroke-color: #999999;
        --edge-color: #cccccc;
        --edge-opacity: 0.8;
      }

      /*******************
       * Graph Container
       *******************/
      .graph-container {
        flex-shrink: 0;
        margin: 10px;
        width: 400px;
        border-radius: 8px;
        border: 1px solid var(--border-color);
        position: sticky;
        top: 88px;
      }

      .graph-inner {
        width: 100%;
        height: 400px;
        border-radius: 0.5rem;
        overflow: hidden;
      }

      .name {
        font-size: 2.5em;
        font-weight: bold;
      }
    </style>
  </head>

  <body>
    <!-- Game of Life Canvas -->
    <canvas
      id="gameOfLife"
      class="game-of-life"
      width="200"
      height="400"
    ></canvas>

    <!-- Header -->
    <header class="header">
      <div class="logo-section">
        <a href="/about" class="logo">BBradz</a>
        <button
          class="theme-toggle"
          onclick="toggleTheme()"
          aria-label="Toggle theme"
        >
          <svg
            class="sun-icon"
            viewBox="0 0 24 24"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <circle cx="12" cy="12" r="4"></circle>
            <path d="M12 2v2"></path>
            <path d="M12 20v2"></path>
            <path d="M4.93 4.93l1.41 1.41"></path>
            <path d="M17.66 17.66l1.41 1.41"></path>
            <path d="M2 12h2"></path>
            <path d="M20 12h2"></path>
            <path d="M6.34 17.66l-1.41 1.41"></path>
            <path d="M19.07 4.93l-1.41 1.41"></path>
          </svg>
          <svg
            class="moon-icon"
            viewBox="0 0 24 24"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
          </svg>
        </button>
      </div>
      <nav class="nav-links">
        <a href="./index.html" class="nav-link">Posts</a>
        <a href="../reading.html" class="nav-link">Library</a>
        <a href="/profile" class="nav-link">Psychological Profile</a>
        <a href="./about.html" class="nav-link">About</a>
      </nav>
    </header>

    <!-- 
      reading-list-layout: 
      The container (reading list) + the smaller graph side by side,
      both now have margin-top to push them below the header.
    -->
    <div class="reading-list-layout">
      <div class="container">
        <h1 class="name" style="margin-bottom: 10px">Library</h1>

        <div class="search-bar">
          <input type="text" id="search" placeholder="Search by term..." />
          <button onclick="searchItems()">Search</button>
        </div>

        <div class="sort-bar">
          <div>
            <button
              id="sort-release"
              onclick="toggleSort(this, 'release', 'desc')"
              style="margin-left: 0px !important"
            >
              Sort by Release Date <span class="sort-arrow"></span>
            </button>
            <button id="sort-time" onclick="toggleSort(this, 'time', 'desc')">
              Sort by Time to Read <span class="sort-arrow"></span>
            </button>
            <button id="filter-read" onclick="toggleReadFilter(this)">
              Filter: All
            </button>
            <button id="filter-YT" onclick="toggleFilterType(this, 'YT')">
              YT
            </button>
            <button id="filter-Arxiv" onclick="toggleFilterType(this, 'Arxiv')">
              Arxiv
            </button>
            <button id="filter-Site" onclick="toggleFilterType(this, 'Site')">
              Site
            </button>
          </div>
          <div id="active-tags" class="active-tag"></div>
        </div>

        <ul id="reading-list"></ul>
      </div>
      <div class="graph-container">
        <div id="root" class="graph-inner"></div>
      </div>
    </div>

    <!-- Scripts for reading list functionality -->
    <script src="functionality.js"></script>
    <script>
      /****************************************
       * Existing reading-list JavaScript code
       ****************************************/
      const readingListData = [
        {
          title: "From Softmax to Sparsemax",
          author: "Martins et. al",
          description:
            "Proposes sparsemax, a new activation function similar to the traditional softmax, but able to output sparse probabilities.",
          tags: ["Machine Learning", "Activation Functions", "Arxiv"],
          readTime: 0.5,
          releaseDate: "2016-02-08",
          isRead: false,
          downloadLink: "https://arxiv.org/pdf/1602.02068",
        },
        {
          title: "Monte Carlo Methods in Financial Engineering",
          author: "Not specified",
          description:
            "A comprehensive guide on Monte Carlo methods applied in financial engineering.",
          tags: ["Finance", "Site"],
          readTime: 16.3,
          releaseDate: "Not specified",
          isRead: false,
          downloadLink:
            "https://www.bauer.uh.edu/spirrong/Monte_Carlo_Methods_In_Financial_Engineering.pdf",
        },
        {
          title: "Information Theory: A Tutorial Introduction",
          author: "University of Sheffield",
          description: "Introduces the main ideas in Shannon’s theory.",
          tags: ["Information Theory", "Shannon", "Arxiv"],
          readTime: 0.5,
          releaseDate: "2019-06-13",
          isRead: false,
          downloadLink: "https://arxiv.org/pdf/1802.05968",
        },
        {
          title: "What Every Programmer Should Know About Memory",
          author: "Redhat",
          description: "An in-depth look at memory management for programmers.",
          tags: ["Programming", "Site"],
          readTime: 6.5,
          releaseDate: "Not specified",
          isRead: false,
          downloadLink:
            "https://people.freebsd.org/~lstewart/articles/cpumemory.pdf",
        },
        {
          title:
            "PowerSGD: Practical Low-Rank Gradient Compression for Distributed Optimization",
          author: "EPFL",
          description:
            "Proposes gradient compressor achieving test performance on par with SGD with consistent wall-clock speedups.",
          tags: ["Optimization", "Distributed Computing", "Arxiv"],
          readTime: 1,
          releaseDate: "2020-02-18",
          isRead: false,
          downloadLink: "https://arxiv.org/pdf/1905.13727",
        },
        {
          title: "Step-by-Step Diffusion: An Elementary Tutorial",
          author: "University of Montreal",
          description: "A tutorial on diffusion models.",
          tags: ["Diffusion Models", "Tutorial", "Arxiv"],
          readTime: 1.5,
          releaseDate: "Not specified",
          isRead: false,
          downloadLink: "https://arxiv.org/pdf/2406.08929",
        },
        {
          title:
            "A Loss Curvature Perspective on Training Instability in Deep Learning",
          author: "Google",
          description:
            "Combine learning rate, model structure, and weight initialization to analyze the evolution of Hessian loss.",
          tags: ["Deep Learning", "Optimization", "Arxiv"],
          readTime: 1,
          releaseDate: "2020-10-08",
          isRead: false,
          downloadLink: "https://arxiv.org/pdf/2110.04369",
        },
        {
          title: "Networks, Crowds, and Markets",
          author: "Cornell University",
          description: "A book exploring networks, crowds, and markets.",
          tags: ["Economics", "Site"],
          readTime: 23.5,
          releaseDate: "Not specified",
          isRead: false,
          downloadLink:
            "https://www.cs.cornell.edu/home/kleinber/networks-book/networks-book.pdf",
        },
        {
          title:
            "Towards Practical Second Order Optimization for Deep Learning",
          author: "Anonymous",
          description:
            "Presents a scalable 2nd-order preconditioner with significant convergence and wall-clock time improvements compared to 1st-order methods.",
          tags: ["Optimization", "Deep Learning", "Site"],
          readTime: 0.6,
          releaseDate: "2021-01-01",
          isRead: false,
          downloadLink: "https://openreview.net/references/pdf?id=80B6V-eoFP",
        },
        {
          title: "Deep Bellman Hedging",
          author: "Buehler et al.",
          description: "A paper on reinforcement learning and hedging.",
          tags: ["Reinforcement Learning", "Arxiv"],
          readTime: 0.6,
          releaseDate: "Not specified",
          isRead: false,
          downloadLink: "https://arxiv.org/pdf/2207.00932",
        },
        {
          title:
            "A Large Batch Optimizer Reality Check: Traditional, Generic Optimizers Suffice Across Batch Sizes",
          author: "Google",
          description:
            "Refutes performance claims of optimizers built around large batch sizes.",
          tags: ["Optimization", "Arxiv"],
          readTime: 0.8,
          releaseDate: "2021-06-09",
          isRead: false,
          downloadLink: "https://arxiv.org/pdf/2102.06356",
        },
        {
          title: "Information Theory, Inference, and Learning Algorithms",
          author: "Cambridge University",
          description:
            "A comprehensive book on information theory, inference, and learning algorithms.",
          tags: ["Machine Learning", "Algorithms", "Site"],
          readTime: 19.6,
          releaseDate: "Not specified",
          isRead: false,
          downloadLink: "https://www.inference.org.uk/itprnn/book.pdf",
        },
        {
          title: "Vector Quantized Models for Planning",
          author: "Not specified",
          description:
            "Presents using discrete autoencoders to capture the multiple effects of an action in a stochastic environment, using MCTS to plan over both actions and discrete latent variables. Significantly outperforming MuZero on a stochastic interpretation of chess.",
          tags: ["Reinforcement Learning", "Autoencoders", "Arxiv"],
          readTime: 0.6,
          releaseDate: "2021-08-06",
          isRead: false,
          downloadLink: "https://arxiv.org/pdf/2106.04615",
        },
        {
          title: "Programming Massively Parallel Applications",
          author: "David B. Kirk",
          description: "A book on programming massively parallel applications.",
          tags: ["Parallel Computing", "Site"],
          readTime: 18.8,
          releaseDate: "Not specified",
          isRead: false,
          downloadLink:
            "https://github.com/h3ct0rjs/HighPerformanceComputing/blob/master/BookRef/Programming%20Massively%20Parallel%20Processors.pdf",
        },
        {
          title:
            "Hyperparameter Optimization Is Deceiving Us, and How to Stop It",
          author: "Cornell University",
          description:
            "Provides a theoretical grounding for process epistemic hyperparameter optimization (EHPO) to avoid deception by hyperparams.",
          tags: ["Hyperparameter Optimization", "Machine Learning", "Arxiv"],
          readTime: 1.3,
          releaseDate: "2021-10-26",
          isRead: false,
          downloadLink: "https://arxiv.org/pdf/2102.03034",
        },
        {
          title:
            "Torch.FX: a Practical Program Capture and Transformation for DL in Python",
          author: "Horace He",
          description:
            "Studies designs for program capture in the typical deep learning use case to propose a library optimizing for developer productivity.",
          tags: ["Deep Learning", "Libraries", "Arxiv"],
          readTime: 0.7,
          releaseDate: "2022-03-04",
          isRead: false,
          downloadLink: "https://arxiv.org/pdf/2112.08429",
        },
        {
          title: "Set Theory",
          author: "Not specified",
          description: "A book on set theory.",
          tags: ["Mathematics", "Site"],
          readTime: "Not specified",
          releaseDate: "Not specified",
          isRead: false,
          downloadLink: "http://www.alefenu.com/libri/topologymunkres.pdf",
        },
        {
          title: "Omnigrok: Grokking Beyond Algorithmic Data",
          author: "MIT",
          description:
            "Understands grokking by analyzing NN loss landscapes, identifying the mismatch between training and test loss as the cause for grokking.",
          tags: ["Neural Networks", "Optimization", "Grokking", "Arxiv"],
          readTime: 0.6,
          releaseDate: "2023-03-23",
          isRead: false,
          downloadLink: "https://arxiv.org/pdf/2210.01117",
        },
        {
          title: "Lie Groups",
          author: "University of Ottowa",
          description: "A book on Lie groups.",
          tags: ["Mathematics", "Lie Groups", "Site"],
          readTime: "Not specified",
          releaseDate: "Not specified",
          isRead: false,
          downloadLink:
            "https://alistairsavage.ca/mat4144/notes/MAT4144-5158-LieGroups.pdf",
        },
        {
          title: "Finding Neurons in a Haystack",
          author: "MIT",
          description:
            "Shows the progression of, violation of, and features embedded in neurons at varying depths of LLM.",
          tags: ["Interpretability", "Neural Networks", "LLMs", "Arxiv"],
          readTime: 1.3,
          releaseDate: "2023-06-02",
          isRead: false,
          downloadLink: "https://arxiv.org/pdf/2305.01610",
        },
        {
          title: "Meta-Learning",
          author: "Lilian Weng",
          description: "A post on meta-learning.",
          tags: ["Meta-Learning", "Machine Learning", "Site"],
          readTime: 2.6,
          releaseDate: "Not specified",
          isRead: false,
          downloadLink:
            "https://lilianweng.github.io/posts/2018-11-30-meta-learning/",
        },
        {
          title: "Uncovering Mesa-optimization algorithms in Transformers",
          author: "Google",
          description:
            "Reverse engineers Transformers to determine that performance comes from an architectural bias towards mesa-optimization.",
          tags: ["Transformers", "Optimization", "LLMs", "Arxiv"],
          readTime: 1.9,
          releaseDate: "2023-09-11",
          isRead: false,
          downloadLink: "https://arxiv.org/pdf/2309.05858",
        },
        {
          title: "Why do we need Weight Decay in modern Deep Learning?",
          author: "EPFL",
          description:
            "Present a unifying perspective from to say that weight decay changes the training dynamics in a desirable way.",
          tags: ["Deep Learning", "Optimization", "Arxiv"],
          readTime: 1.3,
          releaseDate: "2023-10-06",
          isRead: false,
          downloadLink: "https://arxiv.org/pdf/2310.04415",
        },
        {
          title:
            "When, Why and How Much? Adaptive Learning Rate Scheduling by Refinement",
          author: "Meta",
          description:
            "Develops theory supporting the linear decay schedules and refinement techniques, establishing SOTA performance in theory and practice.",
          tags: ["Optimization", "Arxiv"],
          readTime: 1.1,
          releaseDate: "2023-10-11",
          isRead: false,
          downloadLink: "https://arxiv.org/pdf/2310.07831",
        },
        {
          title: "One Wide Feedforward Network is All You Need",
          author: "Apple",
          description:
            "Observes a high redundancy in the Feed-Forward layers of Transformers to unlock substantial gains in accuracy & latency.",
          tags: ["LLMs", "Optimization", "Arxiv"],
          readTime: 0.6,
          releaseDate: "2023-10-21",
          isRead: false,
          downloadLink: "https://arxiv.org/pdf/2309.01826",
        },
        {
          title:
            "DiLoCo: Distributed Low-Communication Training of Language Models",
          author: "Google",
          description:
            "Proposes a distributed optimization algorithm to train LLMs on islands of poorly connected devices.",
          tags: ["LLMs", "Optimization", "Arxiv"],
          readTime: 0.5,
          releaseDate: "2023-12-02",
          isRead: false,
          downloadLink: "https://arxiv.org/pdf/2311.08105",
        },
        {
          title:
            "Reinforcement Learning With Sparse-executing Action via Sparsity Regularization",
          author: "Nanjing University",
          description:
            "Proposes a spinoff of Markov Decision Processes to account for need to sparsify actions.",
          tags: ["Reinforcement Learning", "Arxiv"],
          readTime: 0.8,
          releaseDate: "2024-07-22",
          isRead: false,
          downloadLink: "https://arxiv.org/pdf/2105.08666",
        },
        {
          title: "Literature Review of Sampling Techniques",
          author: "njkumar",
          description:
            "Explains the many types of Sampling techniques for ML Models and their differing strengths.",
          tags: ["Machine Learning", "Site"],
          readTime: 0.3,
          releaseDate: "2024-08-10",
          isRead: false,
          downloadLink:
            "https://njkumar.com/literature-review-sampling-techniques/",
        },
        {
          title:
            "Learning to (Learn at Test Time): RNNs with Expressive Hidden States",
          author: "Sun et al.",
          description:
            "Proposes a new sequence modeling layers with O(n) complexity and an expressive ML model hidden state.",
          tags: ["RNNs", "Machine Learning", "Arxiv"],
          readTime: 1.1,
          releaseDate: "2024-08-11",
          isRead: false,
          downloadLink: "https://arxiv.org/pdf/2407.04620",
        },
        {
          title:
            "Tree Attention: Topology-Aware Decoding for Long-Context Attention on GPU Clusters",
          author: "EleutherAI",
          description:
            "Reveals a self-attention computation parallelizable across multiple GPUs.",
          tags: ["Attention Mechanisms", "Parallel Computing", "Arxiv"],
          readTime: 0.5,
          releaseDate: "2024-08-14",
          isRead: false,
          downloadLink: "https://arxiv.org/pdf/2408.04093",
        },
        {
          title:
            "DeepSeek-Prover-V1.5: Harnessing Proof Assistant Feedback for Reinforcement Learning and Monte-Carlo Tree Search",
          author: "DeepSeek",
          description:
            "Introduces a dataset & RL with proof-solving feedback for fine-tuning on top of MCTS for generating more lush proof paths.",
          tags: ["Reinforcement Learning", "Arxiv"],
          readTime: 0.9,
          releaseDate: "2024-08-15",
          isRead: false,
          downloadLink: "https://arxiv.org/pdf/2408.08152",
        },
        {
          title: "The LLama3 herd of models",
          author: "Meta",
          description:
            "Presents the results of experiments which integrate image, video, and speech capabilities into Llama 3.",
          tags: ["LLMs", "Arxiv"],
          readTime: 3.7,
          releaseDate: "2024-08-15",
          isRead: false,
          downloadLink: "https://arxiv.org/pdf/2407.21783",
        },
        {
          title: "The AdeMAMix optimizer: Better, Faster, Older",
          author: "Apple",
          description:
            "Halves tokens required to train LLM while slowing down forgetting through leveraging the need to remember far back gradients.",
          tags: ["Optimization", "LLMs", "Arxiv"],
          readTime: 1.5,
          releaseDate: "2024-09-05",
          isRead: false,
          downloadLink: "https://arxiv.org/pdf/2409.03137",
        },
        {
          title:
            "Compute Better Spent: Replacing Dense Layers with Structured Matrices",
          author: "Qiu et al.",
          description:
            "Explores structured matrices as replacements for dense matrices as models scale.",
          tags: ["Optimization", "Arxiv"],
          readTime: 0.9,
          releaseDate: "2024-10-06",
          isRead: false,
          downloadLink: "https://arxiv.org/pdf/2406.06248",
        },
        {
          title: "Financial Statement Analysis with Large Language Models",
          author: "Kim et al.",
          description:
            "Investigates whether LLMs can successfully perform financial statement analysis similarly to professional human analysts.",
          tags: ["LLMs", "Finance", "Arxiv"],
          readTime: 1.6,
          releaseDate: "2024-10-11",
          isRead: false,
          downloadLink: "https://arxiv.org/pdf/2407.17866",
        },
        {
          title:
            "The Surprising Effectiveness of Test-Time Training for Abstract Reasoning",
          author: "MIT",
          description:
            "Investigates the effectiveness of test-time training (TTT) as a mechanism for improving reasoning capabilities, using ARC as a benchmark.",
          tags: ["LLMs", "Arxiv"],
          readTime: 0.7,
          releaseDate: "2024-11-11",
          isRead: false,
          downloadLink: "https://arxiv.org/pdf/2411.07279",
        },
        {
          title: "Transformers meet Neural Algorithmic Reasoners",
          author: "Google",
          description:
            "Proposes a novel combination of Transformers with GNN-based neural algorithmic reasoners (NARs) as a hybrid architecture demonstrating significant gains over Transformer-only models for algorithmic reasoning.",
          tags: ["LLMs", "GNNs", "Arxiv"],
          readTime: 0.4,
          releaseDate: "2024-06-13",
          isRead: false,
          downloadLink: "https://arxiv.org/pdf/2406.09308",
        },
        {
          title: "On Empirical Comparison of Optimizers",
          author: "Choi et al.",
          description:
            "Gives tips around tuning often ignored hyperparameters of adaptive gradient methods and raise concerns about fairly benchmarking optimizers for NN training.",
          tags: ["Optimizers", "Deep Learning", "Arxiv"],
          readTime: 0.8,
          releaseDate: "2020-06-16",
          isRead: false,
          downloadLink: "https://arxiv.org/pdf/1910.05446",
        },
        {
          title:
            "DeepSeek-Coder-V2: Breaking the Barrier of Closed-Source Models in Code Intelligence",
          author: "DeepSeek",
          description:
            "DeepSeek-V2 is pre-trained with 6 trillion additional tokens achieving superior coding performance to closed-source models.",
          tags: ["LLMs", "Arxiv"],
          readTime: 0.6,
          releaseDate: "2024-06-17",
          isRead: false,
          downloadLink: "https://arxiv.org/pdf/2406.11931",
        },
        {
          title:
            "DeepSeek-V2: A Strong, Economical, and Efficient Mixture-of-Experts Language Model",
          author: "DeepSeek",
          description:
            "Presents DeepSeek-V2, a strong MoE language model characterized by economical training and efficient inference.",
          tags: ["MoEs", "LLMs", "Arxiv"],
          readTime: 1.3,
          releaseDate: "2024-06-19",
          isRead: false,
          downloadLink: "https://arxiv.org/pdf/2405.04434",
        },
        {
          title: "Why Transformers need Adam: A Hessian Perspective",
          author: "University of Hong Kong",
          description:
            "Provides an explanation through the lens of Hessian of why Adam outperforms SGD on Transformer models.",
          tags: ["Optimizations", "Arxiv"],
          readTime: 1.4,
          releaseDate: "2024-10-21",
          isRead: false,
          downloadLink: "https://arxiv.org/pdf/2402.16788",
        },
        {
          title:
            "Sparse Crosscoders for Cross-Layer Features and Model Diffing",
          author: "Anthropic",
          description:
            "Introduces sparse crosscoders, a variant of sparse autoencoders or transcoders for understanding models in superposition.",
          tags: ["Interpretability", "Site"],
          readTime: 0.6,
          releaseDate: "2024-10-25",
          isRead: false,
          downloadLink:
            "https://transformer-circuits.pub/2024/crosscoders/index.html",
        },
        {
          title: "Beyond A*",
          author: "Meta",
          description:
            "Shows a Transformer model to optimally solve unseen Sokoban puzzles 93.7% of the time with up to 26.8% fewer steps than the A*.",
          tags: ["Transformers", "Pathfinding", "Sokoban", "Arxiv"],
          readTime: 0.8,
          releaseDate: "2024-04-26",
          isRead: false,
          downloadLink: "https://arxiv.org/pdf/2402.14083",
        },
      ];

      function hashString(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = (hash << 5) - hash + char;
          hash = hash & hash;
        }
        return Math.abs(hash);
      }

      function getTagColor(tag) {
        switch (tag) {
          case "YT":
            return "#FF0000";
          case "Arxiv":
            return "#A51C30";
          case "Site":
            return "#F5F5DC";
          default:
            const hash = hashString(tag);
            const hue = hash % 360;
            const saturation = 40 + (hash % 15);
            const lightness = 30 + (hash % 10);
            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }
      }

      function getTextColor(tag) {
        if (tag === "Site") {
          return "#000000";
        }
        return "#FFFFFF";
      }

      // Modified initialization function
      function initializeTagColors() {
        const tags = document.querySelectorAll(".tags span");
        tags.forEach((tag) => {
          const tagType = tag.getAttribute("data-type");
          tag.style.backgroundColor = getTagColor(tagType);
          tag.style.color = getTextColor(tagType);
        });
      }

      // Search functionality
      function searchItems() {
        const searchTerm = document
          .getElementById("search")
          .value.toLowerCase();
        const items = document.querySelectorAll("#reading-list li");
        items.forEach((item) => {
          const text = item.textContent.toLowerCase();
          item.style.display = text.includes(searchTerm) ? "" : "none";
        });
        window.dispatchEvent(window.documentVisibilityChanged);
      }

      function formatDate(dateString) {
        const date = new Date(dateString);
        return date.toLocaleString("en-US", {
          month: "short",
          year: "numeric",
        });
      }

      function generateReadingListHTML(data) {
        const readingList = document.getElementById("reading-list");
        readingList.innerHTML = ""; // Clear existing content

        data.forEach((item) => {
          const li = document.createElement("li");
          li.setAttribute("data-release", item.releaseDate);
          li.setAttribute("data-time", item.readTime);
          li.setAttribute("data-read", item.isRead);

          // Create the HTML structure
          const html = `
      ${item.isRead ? '<span class="read-indicator">&#10003;</span>' : ""}
      <div class="item-header">
        <div class="item-title">
          <strong>"${item.title}" by ${item.author}</strong>
          <span class="meta">${item.isRead ? "Read: " : ""}${formatDate(
            item.releaseDate
          )} | Est. Time ${item.readTime} hours</span>
        </div>
        <div class="tags">
          ${item.tags
            .map(
              (tag) => `
            <span data-type="${tag}" onclick="filterByTag('${tag}')">${tag}</span>
          `
            )
            .join("")}
        </div>
      </div>
      <div class="description">
        ${item.description}
      </div>
      ${
        item.downloadLink
          ? `
        <a class="download-link" href="${item.downloadLink}" download>Download Marked PDF</a>
      `
          : ""
      }
    `;

          li.innerHTML = html;
          readingList.appendChild(li);
        });

        // Initialize tag colors after generating the list
        initializeTagColors();
      }

      // Initialize search input listener
      document.addEventListener("DOMContentLoaded", () => {
        generateReadingListHTML(readingListData);
        const searchInput = document.getElementById("search");
        if (searchInput) {
          searchInput.addEventListener("input", searchItems);
        }
        initializeTagColors();
      });

      // Read filter state management
      let readFilterState = 0;

      function toggleReadFilter(button) {
        const items = document.querySelectorAll("#reading-list li");

        switch (readFilterState) {
          case 0:
            button.textContent = "Filter: Read";
            button.classList.add("active");
            items.forEach((item) => {
              const isRead = item.getAttribute("data-read") === "true";
              item.style.display = isRead ? "" : "none";
            });
            readFilterState = 1;
            break;

          case 1:
            button.textContent = "Filter: Unread";
            items.forEach((item) => {
              const isRead = item.getAttribute("data-read") === "true";
              item.style.display = !isRead ? "" : "none";
            });
            readFilterState = 2;
            break;

          case 2:
            button.textContent = "Filter: All";
            button.classList.remove("active");
            items.forEach((item) => {
              item.style.display = "";
            });
            readFilterState = 0;
            break;
        }
        window.dispatchEvent(window.documentVisibilityChanged);
      }

      function toggleSort(button, criteria) {
        const currentOrder = button.dataset.order || "unsorted";
        let newOrder;

        if (currentOrder === "unsorted") {
          newOrder = "asc";
        } else if (currentOrder === "asc") {
          newOrder = "desc";
        } else {
          newOrder = "unsorted";
        }

        const buttons = document.querySelectorAll(".sort-bar button");
        buttons.forEach((btn) => {
          btn.classList.remove("active");
          const arrowSpan = btn.querySelector(".sort-arrow");
          if (arrowSpan) arrowSpan.textContent = "";
        });

        if (newOrder !== "unsorted") {
          button.classList.add("active");
          button.dataset.order = newOrder;

          const arrowSpan = button.querySelector(".sort-arrow");
          if (arrowSpan) arrowSpan.textContent = newOrder === "asc" ? "↑" : "↓";

          sortBy(criteria, newOrder);
        } else {
          button.dataset.order = "unsorted";
          resetList(false);
        }
      }

      function toggleFilterType(button, type) {
        const isActive = button.classList.contains("active");
        const buttons = document.querySelectorAll(".sort-bar button");
        buttons.forEach((btn) => {
          if (btn !== document.getElementById("filter-read")) {
            btn.classList.remove("active");
            btn.style.removeProperty("--active-color");
            btn.style.removeProperty("--active-text-color");
          }
        });

        if (!isActive) {
          button.classList.add("active");
          switch (type) {
            case "YT":
              button.style.setProperty("--active-color", "#FF0000");
              button.style.setProperty("--active-text-color", "#FFFFFF");
              break;
            case "Arxiv":
              button.style.setProperty("--active-color", "#A51C30");
              button.style.setProperty("--active-text-color", "#FFFFFF");
              break;
            case "Site":
              button.style.setProperty("--active-color", "#F5F5DC");
              button.style.setProperty("--active-text-color", "#000000");
              break;
          }
          filterByType(type);
        } else {
          button.style.removeProperty("--active-color");
          button.style.removeProperty("--active-text-color");
          resetList();
          window.dispatchEvent(window.documentVisibilityChanged);
        }
      }

      function sortBy(criteria, order) {
        const list = document.getElementById("reading-list");
        const items = Array.from(list.children);

        items.sort((a, b) => {
          let valueA =
            criteria === "release"
              ? new Date(a.dataset.release)
              : parseFloat(a.dataset.time);
          let valueB =
            criteria === "release"
              ? new Date(b.dataset.release)
              : parseFloat(b.dataset.time);

          return order === "asc" ? valueA - valueB : valueB - valueA;
        });

        items.forEach((item) => list.appendChild(item));
      }

      function filterByType(type) {
        const items = document.querySelectorAll("#reading-list li");
        items.forEach((item) => {
          const tags = Array.from(item.querySelectorAll(".tags span"));
          const hasTag = tags.some((tag) => tag.dataset.type === type);
          item.style.display = hasTag ? "" : "none";
        });
        window.dispatchEvent(window.documentVisibilityChanged);
      }

      function filterByTag(tag) {
        const activeTags = document.getElementById("active-tags");
        if (
          !Array.from(activeTags.children).some((t) => t.textContent === tag)
        ) {
          const tagSpan = document.createElement("span");
          tagSpan.textContent = tag;
          tagSpan.dataset.type = tag;
          tagSpan.style.backgroundColor = getTagColor(tag);
          tagSpan.style.color = getTextColor(tag);

          tagSpan.onclick = () => {
            tagSpan.remove();
            refreshFilters();
          };

          activeTags.appendChild(tagSpan);
          refreshFilters();
        }
      }

      function refreshFilters() {
        const activeTags = Array.from(
          document.getElementById("active-tags").children
        ).map((t) => t.textContent);
        const items = document.querySelectorAll("#reading-list li");

        items.forEach((item) => {
          const tags = Array.from(item.querySelectorAll(".tags span")).map(
            (tag) => tag.textContent
          );
          const matches = activeTags.every((tag) => tags.includes(tag));
          item.style.display = matches || activeTags.length === 0 ? "" : "none";
        });
        window.dispatchEvent(window.documentVisibilityChanged);
      }

      function resetList(shouldUpdateGraph = true) {
        const items = document.querySelectorAll("#reading-list li");
        items.forEach((item) => {
          item.style.display = "";
        });
        if (shouldUpdateGraph) {
          window.dispatchEvent(window.documentVisibilityChanged);
        }
      }

      document.addEventListener("DOMContentLoaded", initializeTagColors);
    </script>

    <!-- 
      ----------------------------------------------------------
      React, D3, Babel, TensorFlow, and the Graph code go below 
      ----------------------------------------------------------
    -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/universal-sentence-encoder"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Graph code in a <script type="text/babel"> block -->
    <script type="text/babel">
      const { useState, useRef, useEffect, useCallback } = React;
      const use = window.use;

      window.documentVisibilityChanged = new Event("documentVisibilityChanged");

      const generateEmbeddingsWithCache = async (
        documents,
        model,
        batchSize = 10
      ) => {
        if (!model || !documents || documents.length === 0) return null;

        const cachedEmbeddings =
          JSON.parse(localStorage.getItem("documentEmbeddings")) || {};
        const newDocuments = [];
        const cachedResults = [];

        const hashDocument = (doc) =>
          btoa(unescape(encodeURIComponent(doc.content)));

        for (const doc of documents) {
          const docHash = hashDocument(doc);
          if (cachedEmbeddings[docHash]) {
            cachedResults.push(cachedEmbeddings[docHash]);
          } else {
            newDocuments.push({ ...doc, hash: docHash });
          }
        }

        if (newDocuments.length > 0) {
          try {
            const contents = newDocuments.map((doc) => doc.content);
            const batchedEmbeddings = [];

            for (let i = 0; i < contents.length; i += batchSize) {
              const batch = contents.slice(i, i + batchSize);
              const embeddings = await model.embed(batch);
              const batchArray = await embeddings.array();
              batchedEmbeddings.push(...batchArray);
            }

            newDocuments.forEach((doc, index) => {
              cachedEmbeddings[doc.hash] = batchedEmbeddings[index];
              cachedResults.push(batchedEmbeddings[index]);
            });

            localStorage.setItem(
              "documentEmbeddings",
              JSON.stringify(cachedEmbeddings)
            );
          } catch (error) {
            console.error("Error generating embeddings:", error);
            return null;
          }
        }

        return cachedResults;
      };

      const cosineSimilarity = (vecA, vecB) => {
        const dotProduct = vecA.reduce((acc, val, i) => acc + val * vecB[i], 0);
        const normA = Math.sqrt(vecA.reduce((acc, val) => acc + val * val, 0));
        const normB = Math.sqrt(vecB.reduce((acc, val) => acc + val * val, 0));
        return dotProduct / (normA * normB);
      };

      const DocumentGraph = ({ width, height }) => {
        const containerRef = useRef(null);
        const [model, setModel] = useState(null);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);
        const [visibleDocs, setVisibleDocs] = useState([]);
        const svgRef = useRef(null);
        const simulationRef = useRef(null);

        const threshold = 0.75;
        const padding = -200;

        const boundPosition = (position, dimension, padding) => {
          return Math.max(padding, Math.min(dimension - padding, position));
        };

        const getVisibleDocuments = useCallback(() => {
          const items = Array.from(
            document.querySelectorAll("#reading-list li")
          );
          const visibleItems = items.filter(
            (item) => item.style.display !== "none"
          );

          if (visibleItems.length === 0) {
            if (items.length === 0) {
              return window.readingListData;
            }
            return [];
          }

          return visibleItems
            .map((item) => {
              const titleElement = item.querySelector(".item-title strong");
              if (!titleElement) return null;
              const titleText = titleElement.textContent;
              const title = titleText.match(/"([^"]+)"/)?.[1];
              if (!title) return null;
              return window.readingListData.find((doc) => doc.title === title);
            })
            .filter(Boolean);
        }, []);

        useEffect(() => {
          const handleVisibilityChange = () => {
            const currentVisibleDocs = getVisibleDocuments();
            setVisibleDocs(currentVisibleDocs);
          };

          setVisibleDocs(window.readingListData);
          window.addEventListener(
            "documentVisibilityChanged",
            handleVisibilityChange
          );

          return () => {
            window.removeEventListener(
              "documentVisibilityChanged",
              handleVisibilityChange
            );
          };
        }, [getVisibleDocuments]);

        useEffect(() => {
          const loadModel = async () => {
            try {
              setLoading(true);
              const loadedModel = await use.load();
              setModel(loadedModel);
              setLoading(false);
            } catch (err) {
              console.error("Error loading model:", err);
              setError(
                "Failed to load the model. Please check console for details."
              );
              setLoading(false);
            }
          };
          loadModel();
        }, []);

        const cleanupGraph = useCallback(() => {
          if (simulationRef.current) {
            simulationRef.current.stop();
            simulationRef.current = null;
          }

          if (containerRef.current) {
            const container = d3.select(containerRef.current);
            container.selectAll("*").remove();
          }
        }, []);

        useEffect(() => {
          if (!containerRef.current || !model || loading) return;

          // Clean up previous graph
          cleanupGraph();

          // Create fresh SVG
          const container = d3.select(containerRef.current);
          const svg = container
            .append("svg")
            .attr("width", width)
            .attr("height", height)
            .attr("class", "rounded-lg");

          svgRef.current = svg;

          svg
            .append("rect")
            .attr("width", "100%")
            .attr("height", "100%")
            .attr("fill", "var(--graph-background)");

          // If no docs, show the message and return early
          if (!visibleDocs.length) {
            const textGroup = svg
              .append("g")
              .attr("transform", `translate(${width / 2}, ${height / 2})`);

            textGroup
              .append("text")
              .attr("text-anchor", "middle")
              .attr("fill", "var(--text-color)")
              .text("No documents to display");

            return;
          }

          const g = svg.append("g");
          const zoom = d3
            .zoom()
            .scaleExtent([0.1, 3]) // Adjust zoom scale extent as needed
            .on("zoom", (event) => {
              g.attr("transform", event.transform);
            });

          // Starting Conditions
          const initialTranslateX = width / 3 - 10; // Move view horizontally
          const initialTranslateY = height / 4 + 12; // Move view vertically
          const initialScale = 0.4; // Zoom out for a wider view

          svg.call(
            zoom.transform,
            d3.zoomIdentity
              .translate(initialTranslateX, initialTranslateY)
              .scale(initialScale)
          );

          svg.call(zoom);

          const initializeGraph = async () => {
            console.log("Initializing graph with docs:", visibleDocs.length);

            const processedDocs = visibleDocs.map((doc) => ({
              content: `${doc.title} ${doc.description} ${doc.tags.join(" ")}`,
            }));

            const embeddings = await generateEmbeddingsWithCache(
              processedDocs,
              model,
              10
            );
            if (!embeddings) {
              console.error("No embeddings generated");
              return;
            }

            console.log("Generated embeddings successfully");

            const nodes = visibleDocs.map((doc, i) => ({
              id: String(i),
              title: doc.title,
              fullText: doc.description,
              tags: doc.tags,
              readTime: doc.readTime,
              releaseDate: doc.releaseDate,
              isRead: doc.isRead,
            }));

            const links = [];
            for (let i = 0; i < visibleDocs.length; i++) {
              for (let j = i + 1; j < visibleDocs.length; j++) {
                const similarity = cosineSimilarity(
                  embeddings[i],
                  embeddings[j]
                );
                if (similarity > threshold) {
                  links.push({
                    source: String(i),
                    target: String(j),
                    similarity,
                    width: 1 + (similarity - threshold) * (4 / (1 - threshold)),
                  });
                }
              }
            }

            console.log(
              "Setting up force simulation with nodes:",
              nodes.length
            );

            // Initialize positions for nodes
            nodes.forEach((node) => {
              node.x = width / 2 + (Math.random() - 0.5) * 100;
              node.y = height / 2 + (Math.random() - 0.5) * 100;
            });

            simulationRef.current = d3
              .forceSimulation()
              .nodes(nodes)
              .force(
                "link",
                d3
                  .forceLink(links)
                  .id((d) => d.id)
                  .distance(60)
                  .strength(0.3)
              )
              .force("charge", d3.forceManyBody().strength(-800))
              .force("center", d3.forceCenter(width / 2, height / 2))
              .force("x", d3.forceX(width / 2).strength(0.1))
              .force("y", d3.forceY(height / 2).strength(0.1))
              .force("collision", d3.forceCollide().radius(25))
              .velocityDecay(0.3)
              .alphaTarget(0)
              .alphaDecay(0.02);

            const link = g
              .append("g")
              .selectAll("line")
              .data(links)
              .join("line")
              .attr("stroke", "var(--edge-color)")
              .attr("stroke-width", (d) => d.width)
              .attr("stroke-opacity", "var(--edge-opacity)");

            const edgeLabels = g
              .append("g")
              .selectAll("text")
              .data(links)
              .join("text")
              .attr("fill", "var(--text-color)")
              .attr("font-size", "10px")
              .text((d) => d.similarity.toFixed(2));

            console.log("Creating node elements");

            const nodeGroup = g.append("g").attr("class", "nodes");

            const node = nodeGroup
              .selectAll("g")
              .data(nodes)
              .join("g")
              .attr("transform", (d) => `translate(${d.x},${d.y})`)
              .call(
                d3
                  .drag()
                  .on("start", dragstarted)
                  .on("drag", dragged)
                  .on("end", dragended)
              );

            node
              .append("circle")
              .attr("r", 8)
              .attr("fill", (d) => (d.isRead ? "#4caf50" : "var(--node-color)"))
              .attr("stroke", "var(--node-stroke-color)");

            // node
            //   .append("text")
            //   .text((d) => d.title)
            //   .attr("x", 12)
            //   .attr("y", 3)
            //   .attr("fill", "var(--text-color)")
            //   .attr("class", "text-sm");

            node
              .append("title")
              .text(
                (d) =>
                  `${d.title}\n${d.fullText}\nTags: ${d.tags.join(
                    ", "
                  )}\nRead Time: ${d.readTime} hours\nRelease Date: ${
                    d.releaseDate
                  }`
              );

            function dragstarted(event, d) {
              if (!event.active)
                simulationRef.current.alphaTarget(0.3).restart();
              d.fx = d.x;
              d.fy = d.y;
            }

            function dragged(event, d) {
              d.fx = boundPosition(event.x, width, padding);
              d.fy = boundPosition(event.y, height, padding);
            }

            function dragended(event, d) {
              if (!event.active) simulationRef.current.alphaTarget(0);
              d.fx = null;
              d.fy = null;
            }

            console.log("Setting up tick handler");

            simulationRef.current.on("tick", () => {
              // Update link positions
              link
                .attr("x1", (d) => boundPosition(d.source.x, width, padding))
                .attr("y1", (d) => boundPosition(d.source.y, height, padding))
                .attr("x2", (d) => boundPosition(d.target.x, width, padding))
                .attr("y2", (d) => boundPosition(d.target.y, height, padding));

              // Update edge label positions
              edgeLabels
                .attr(
                  "x",
                  (d) =>
                    (boundPosition(d.source.x, width, padding) +
                      boundPosition(d.target.x, width, padding)) /
                    2
                )
                .attr(
                  "y",
                  (d) =>
                    (boundPosition(d.source.y, height, padding) +
                      boundPosition(d.target.y, height, padding)) /
                    2
                );

              // Update node positions
              node.attr("transform", (d) => {
                const x = boundPosition(d.x, width, padding);
                const y = boundPosition(d.y, height, padding);
                return `translate(${x},${y})`;
              });
            });

            console.log("Graph initialization complete");
          };

          initializeGraph();

          return () => {
            cleanupGraph();
          };
        }, [visibleDocs, width, height, model, loading, padding, cleanupGraph]);

        if (loading) {
          return (
            <div
              className="flex items-center justify-center rounded-lg"
              style={{
                width,
                height,
                backgroundColor: "var(--graph-background)",
                color: "var(--text-color)",
              }}
            >
              <p>Loading Embeddings</p>
            </div>
          );
        }

        if (error) {
          return (
            <div
              className="flex items-center justify-center h-32 rounded-lg"
              style={{
                backgroundColor: "var(--graph-background)",
                color: "var(--text-color)",
              }}
            >
              <p className="text-red-600">{error}</p>
            </div>
          );
        }

        return <div ref={containerRef} className="w-full h-full" />;
      };

      const App = () => {
        return (
          <div className="space-y-6">
            <DocumentGraph width={400} height={400} />
          </div>
        );
      };

      // Make readingListData globally available before rendering
      window.readingListData = readingListData;

      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<App />);
    </script>
  </body>
</html>
